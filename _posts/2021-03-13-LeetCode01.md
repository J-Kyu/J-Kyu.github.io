---
layout: post
title: Week 1 LeetCode
tags: [Algorithm,LeetCode]
---
# LeetCode: Week 1

## [2. Add Two Number](https://leetcode.com/problems/add-two-numbers/)

### Brute force

Time Complexity: O(N), where N is longest length of ``l1`` and ``l2``

Space Complexity: O(N)

**Key-point**: return Header->Next

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """

        
        headNode = curNode= ListNode()
        carry = 0
        
        while l1 != None or l2 != None or carry > 0:
            if l1:
                carry += l1.val
                l1 = l1.next
            if l2:
                carry += l2.val
                l2 = l2.next
                
            curNode.next = ListNode(carry%10)
            curNode = curNode.next
            carry //= 10
    
        return headNode.next
        
```

## [3.Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

### Sliding Window

Time-Complexity: O(N), where N is length of ``s``

Space-Complexity: O(min(m,n)), where _n_ is upper bound of set, _m_ is length of ``s``

**Key-point**: Sliding Window & Set

```python
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        
        # Sliding Window
        
        """
        [abcabcbb]
        a       1
        ab      2
        abc     3
        -abca   
        bca     3   
        -bcab   
        cab     3
        -cabc   
        abc     3
        -abcb   
        -bcb    
        cb      2
        -cbb
        -bb
        b       1
        """
        maxLen = 0
        overlap = set()
        startIndex = 0
        endIndex = 0
        
        while endIndex < len(s):
            if s[endIndex] in overlap:
                overlap.remove(s[startIndex])
                startIndex += 1
            else:
                overlap.add(s[endIndex])
                maxLen = max(maxLen,endIndex - startIndex +1)
                endIndex += 1
           
        return maxLen
```

### Sliding Window Optimized