---
layout: post
title: Week 5 LeetCode
tags: [Algorithm,LeetCode]
---
# LeetCode: Week 5

## [91. Decode Ways](https://leetcode.com/problems/decode-ways/) :star::star:

### 

Time Complexity: $$O()$$

Space Complexity: $$O()$$

**Key-Point**: When single digit is valid, we add from ``dp[i-1]``. When double digit is valide we add ``dp[i-1]`` with ``dp[i-2]``.
Single Digit dp[i] += dp[i-1]
Double Digit dp[i] += dp[i-2]   (dp[i] = dp[i-1] + dp[i-2])
To be more specific, when given number is "216", the ``dp`` will be formed as following.
 
 Index] 0 | 1 | 2 | 3 |
        ------------------ 
value]    | 2 | 1 | 6 |
        ==================
dp]     1 | 1 | 2 | 3 |
 
 
``dp[2]`` is equal to 2 because both value ``2`` and ``23`` is valid. 
``dp[3]'' is equal to 3 because ``16`` and ``6`` is valid. Also previous value ``2`` and ``23`` is valid. Thus adding ``dp[i-1]`` and ``dp[i-2]`` is valid way to decode ``216``.



```python
class Solution(object):
    def numDecodings(self, s):
        """
        :type s: str
        :rtype: int
        """
        
        #dp: accumulate valid one (2 cases)
        #s =    | 1 | 1 | 0 | 1
        #    --------------------
        #dp   1 | 1 | 2 | 1 | 1
        
        
        
        dp = [ 0 for _ in range(len(s)+1)]
        
        if not s or s[0] == "0":
            return 0
            
        dp[0] = 1
        
        for i in range(1,len(s)+1):
            
            # single digit  1~9
            if s[i-1] != "0":
                dp[i] += dp[i-1]
                
            # double digit    09~27  (value between 01~09 is already been considered from above condition ) 
            if i > 1 and s[i-2:i] < "27" and s[i-2:i] > "09":
                dp[i] += dp[i-2]
                
                
        return dp[len(s)]
```

## [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) :star::star::star:

### Iterative Link Reversal.

Time Complexity: $$O(N)$$

Space Complexity: $$O(1)$$

**Key-point:**
1. Connect seconde node from left node with left node.
2. Insert next node of leftNode on the next of base Node(preNode). 



```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def reverseBetween(self, head, left, right):
        """
        :type head: ListNode
        :type left: int
        :type right: int
        :rtype: ListNode
        """
        
        newHead = ListNode(0,head)
        curNode = newHead
        preNode = None
        leftNode = None
        

        for i in range(left):
                preNode = curNode
                leftNode = curNode.next
                curNode = curNode.next
        
        for i in range(right-left) :
                #connecting second node form left node with left node
                temp = leftNode.next
                leftNode.next = temp.next
                
                # insert next node of left node on previous node
                temp.next = preNode.next
                preNode.next = temp
                          
        return newHead.next
```



## [93. Restore IP Addresses](https://leetcode.com/problems/restore-ip-addresses/) :star::star:

### Backtracking

Time Complexity: $$O(N)$$

Space Complexity: $$O(1)$$

**Key-point:**
```python
```


## [94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/) :star::star:

### Recusrive

Time Complexity: $$O(N)$$

Space Complexity: $$O(1)$$

**Key-point:**
```python
```

### Stack

Time Complexity: $$O(N)$$

Space Complexity: $$O(1)$$

**Key-point:**
```python
```


## [95. Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/) :star::star:

### DP :star: :star: :star:

Time Complexity: $$O()$$

Space Complexity: $$O()$$

**Key-point:** 
        F(i)
        /  \
  F(1~i-1)  F(i+1~n)
```python
```
