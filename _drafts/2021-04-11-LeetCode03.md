---
layout: post
title: Week 1 LeetCode
tags: [Algorithm,LeetCode]
---
# LeetCode: Week 3

> :star: : Hard Coding
>
> :star::star: : Basic Question
>
> :star::star::star: : Twisted but worthy
>
> :star::star::star::star:: Discerning

## [45.Jump Game II](https://leetcode.com/problems/jump-game-ii/) :star::star:

### DP

Time Complexity: $$O(N^2)$$

Space Complexity: $$O(N)$$

**Key-Point**: We save index of reachable and longest value of ``nums`` at ``dp``.

```python
class Solution(object):
    def jump(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        dp = [0 for _ in range(n)]
        
        for i in range(1,n):
            
            mxIndex = i-1
            for j in range(i):
                distance = i -j
                if distance <= nums[j] and dp[j] < dp[mxIndex]:
                    mxIndex = j
            dp[i] = dp[mxIndex] + 1
            
        return dp[n-1]
```

###  Greedy :star::star::star: (Retry)

Time Complexity: $$O(N)$$

Space Complexity: $$O(1)$$

**Key-Point**: As we go through ``nums``, we aim at the possible longest index as target. Once we reach the target index we increment one.

```python
class Solution(object):
    def jump(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # greedy
        
        n = len(nums)
        
        jumpCount = 0
        targetJumpIndex = 0
        longestDistance = 0
        
        for i in range(n-1):
            longestDistance = max(longestDistance, i + nums[i])
            
            if i == targetJumpIndex:
                jumpCount += 1
                targetJumpIndex = longestDistance
        return jumpCount
```

## [55. Jump Game](https://leetcode.com/problems/jump-game/)

###  Greedy :star:

Time Complexity: $$O(N)$$

Space Complexity: $$O(1)$$

**Key-Point**: Check the  farthest Index and update when you reach the farthest Index

```python
class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """  
        # Greedy 
        n = len(nums)
        mostFar = 0
        aimIndex = 0
        
        for i in range(n):
            mostFar = max(mostFar,i + nums[i]) 
                
            if i == aimIndex:
                    aimIndex = mostFar
        if n-1 > aimIndex:
            return False
        else:
            return True
```



## [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)

### Sort :star:

Time Complexity: $$O(N)$$

Space Complexity: $$O(N)$$

**Key-Point**: Compare current interval with last value from out list.

```python
class Solution(object):
    def merge(self, intervals):
        out = []
        intervals.sort() 
        for i in intervals:
            #change...either merge or extend
            if out and i[0] <= out[-1][1]:
                out[-1][1] = max(out[-1][1], i[1])
            #append
            else:
                out += i,
        return out
```

