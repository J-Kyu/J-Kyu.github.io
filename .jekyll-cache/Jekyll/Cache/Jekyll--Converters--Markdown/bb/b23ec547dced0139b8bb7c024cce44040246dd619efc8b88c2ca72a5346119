I"ï&
<h1 id="computer-graphic_1-2">Computer Graphic_1-2</h1>

<blockquote>
  <h3 id="opengl-introduction">OpenGL-Introduction</h3>

  <ul>
    <li>Rendering</li>
    <li>Shaders</li>
    <li>OpenGLâ€™s Rendering Pipeline</li>
    <li>OpenGL Syntax</li>
    <li>OpenGL Shading Language (GLSL)</li>
    <li>First OpenGL Program</li>
  </ul>
</blockquote>

<h2 id="rendering">Rendering</h2>

<h3 id="definition">Definition</h3>

<ul>
  <li>Automatic process of <strong>generating a photorealistic or non-photorealistic Image</strong> from 2D or 3D models using computer programs.</li>
  <li>Renderì„ í•˜ê¸° ìœ„í•´ì„œëŠ” ë‹¹ì—°íˆ(synthesize image), ë‹¤ìŒê³¼ ê°™ì€ ì •ë³´ë“¤ì´ í•„ìš”í•˜ë‹¤.
    <ul>
      <li>Material properties</li>
      <li>Light Souces</li>
      <li>Cameras</li>
      <li>Motion</li>
      <li>Texture</li>
      <li>Shape of Object</li>
      <li>etc</li>
    </ul>
  </li>
</ul>

<h2 id="shaders">Shaders</h2>

<blockquote>
  <p>Recent Tech</p>
</blockquote>

<h3 id="definition-1">Definition</h3>

<ul>
  <li>ì˜¤ëŠ˜ ë‚ ,  CG softwareì—ì„œëŠ” shaderë¥¼ ë§ì´ ì‚¬ìš©í•œë‹¤.</li>
  <li>ShaderëŠ” <strong>user-defined program</strong>ìœ¼ë¡œ <strong>rendering workë¥¼ control/modify</strong>í•˜ëŠ” ê¸°ëŠ¥ì„ í•œë‹¤.</li>
  <li>run-time efficiencyë¥¼ ìœ„í•´ì„œ GPUì—ì„œ ë³‘ë ¬ë¡œ(excuted in parallel)ì²˜ë¦¬ ëœë‹¤.</li>
</ul>

<h2 id="opengls-rendering-pipeline">OpenGLâ€™s Rendering Pipeline</h2>

<blockquote>
  <ul>
    <li>A sequence of stage for converting graphics data into a final image</li>
    <li>Two required Shader for OpenGL
      <ul>
        <li>Vertex Shader</li>
        <li>Fragment Shader</li>
      </ul>
    </li>
    <li>ì´ ë‘ê°œì˜ shaderëŠ” OpenGLì„ ë‹¤ë£¨ëŠ” programmerê°€ êµ¬í˜„í•´ì•¼ í•œë‹¤.</li>
    <li>ì´ ì™¸ì˜ stageëŠ” ì´ë¯¸  OpenGLì—ì„œ ì œê³µí•´ì¤€ë‹¤.</li>
  </ul>
</blockquote>

<pre><code class="language-mermaid">graph LR
	s(("Vertex Data"))--&gt; A["Vertex Shader"] --&gt; B["Primitive Assembly"] --&gt; C["Projection &amp; Clipping"] --&gt;D["Rasterization"] --&gt; E["Fragment Shader"] --&gt; F["Pre-fragment Operations"]--&gt; G["Framebuffer"];
	Y(("Pixel Data"))--&gt;Z["Texture Memory"]--&gt;E
</code></pre>

<h3 id="vertex-shader-basic-shader">Vertex Shader (Basic Shader)</h3>

<ul>
  <li>Vertex Dataë¥¼ í†µí•´ ê¸°ë³¸ geometryë¥¼ ì–»ëŠ”ë‹¤.</li>
  <li>ì—¬ê¸°ì„œëŠ” Vertex Dataë¥¼ ê°€ê³µí•˜ëŠ” ë‹¨ê³„ì´ë‹¤.</li>
  <li>GLSLì„ í†µí•´ì„œ ì§„í–‰</li>
  <li><strong>ì </strong></li>
</ul>

<h3 id="primitive-assembly">Primitive Assembly</h3>

<ul>
  <li>Vertexë¥¼ assebleí•˜ì—¬ triangleì„ ë§Œë“ ë‹¤.</li>
  <li><strong>ë©´</strong></li>
</ul>

<h3 id="projection--clipping--rasterization">Projection &amp; Clipping + Rasterization</h3>

<ul>
  <li>Projection &amp; Clipping
    <ul>
      <li>ì „ lectureì—ì„œ,  Synthetic Camear Modelì„ ì‚¬ìš©í•œë‹¤ê³  í•˜ì˜€ë‹¤.</li>
      <li>ì´ ë‹¨ê³„ì—ì„œëŠ” ì‚¬ë¬¼ì´ Projection Planeì— ë¹„ì¶°ì§€ëŠ” ì‘ì—…ì„ ë‹´ë‹¹í•œë‹¤.</li>
    </ul>
  </li>
  <li>Rasterization
    <ul>
      <li>Projection Planeì— ê·¸ë ¤ì§„ ì‚¬ë¬¼ì„ pixel gridë¡œ ê°€ê³µí•˜ëŠ” ë‹¨ê³„ì´ë‹¤.</li>
    </ul>
  </li>
</ul>

<h3 id="texture-memory--fragment-shaderbasic-shader">Texture Memory + Fragment Shader(Basic Shader)</h3>

<ul>
  <li>Texture Memory
    <ul>
      <li>ì‚¬ë¬¼ì˜ surface imagë¥¼ ì„¤ì •í•  ìˆ˜ ìˆë‹¤.</li>
    </ul>
  </li>
  <li>Fragment Shader
    <ul>
      <li>colorë¥¼ ì„¤ì •í•œë‹¤</li>
    </ul>
  </li>
</ul>

<h3 id="per-fragment-operation--framebuffer">Per-Fragment Operation + Framebuffer</h3>

<ul>
  <li>Per-Fragment Operation
    <ul>
      <li>Fragment Shader ë‹¨ê³„ê¹Œì§€ ê³„ì‚°ëœ  dataë¥¼ framebufferë¡œ ì˜®ê¸°ëŠ” ì‘ì—…ì„ í•œë‹¤.</li>
      <li>êµìˆ˜ë‹˜ê¼ì„œ ì˜ˆëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
        <ul>
          <li>ë‘ê°œì˜ ì„œë¡œ ë‹¤ë¥¸  objectê°€ ì¡´ì¬í•œë‹¤.</li>
          <li>í•œ  bufferì— ê²¹ì¹˜ëŠ” ê²½ìš°, ê²¹ì¹˜ëŠ” ê²ƒì„ í‘œí˜„í•´ì•¼í•œë‹¤.(ê²¹ì¹˜ëŠ” ì¼ì • ë¶€ë¶„ì€ ê°€ë ¤ì§„ë‹¤ëŠ” ì˜ë¯¸)</li>
          <li>ì´ëŸ¬í•œ ê³„ì‚°ì„ ì—¬ê¸°ì„œ í•˜ëŠ” ê²ƒ ê°™ë‹¤.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Framebuffer
    <ul>
      <li>ë§ˆì§€ë§‰ imageëŠ” framebufferì— ê·¸ë ¤ì§„ë‹¤.</li>
      <li>ë¬¼ë¡ , ì´ frame bufferê°€ deviceì— ê·¸ë ¤ì§€ëŠ” ê²ƒì´ ìµœì¢… ë‹¨ê³„ì´ê² ì§€ë§Œâ€¦â€¦</li>
    </ul>
  </li>
</ul>

<h2 id="opengl-syntax">OpenGL Syntax</h2>

<h3 id="basic-syntax">Basic Syntax</h3>

<ul>
  <li><strong>Constant</strong>
    <ul>
      <li>Begin with â€œGLâ€</li>
      <li>Ex) GL_COLOR_BUFFER_BIT</li>
    </ul>
  </li>
  <li><strong>Functions</strong>
    <ul>
      <li>Begin with â€œglâ€</li>
      <li>Ex) glBindVertexArray()</li>
    </ul>
  </li>
  <li><em>OpenGL has no overloaded functions</em></li>
</ul>

<h3 id="data-types">Data Types</h3>

<ul>
  <li>ì„ ì–¸ í•˜ê¸° ìœ„í•œ Typeì´ ì •í•´ì ¸ ìˆë‹¤</li>
  <li>For more details and types, see https://www.khronos.org/opengl/wiki/OpenGL_Type.</li>
</ul>

<h3 id="function-suffix">Function Suffix</h3>

<ul>
  <li>FunctionName{&lt;\the # of parameters&gt;}{&lt;\Data Type&gt;}{&lt;\Vector&gt;}</li>
  <li><a href="https://monochromelux.github.io/opengl/">OpenGL í•¨ìˆ˜ í•œê¸€ ì„¤ëª…ì„œ</a></li>
  <li>Note: there are 24 versions of glUniform*(). For more details, see the following link: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml.</li>
</ul>

<h2 id="opengl-shading-language-glsl">OpenGL Shading Language (GLSL)</h2>

<ul>
  <li>Shaderë¥¼ programmingí•˜ê¸° ìœ„í•œ ì–¸ì–´</li>
  <li><a href="https://www.opentutorials.org/module/3659">GLSL/Shader Tutorial ê°•ì˜</a></li>
</ul>

<h3 id="glutopengl-utility-toolkit">GLUT(OpenGL Utility Toolkit)</h3>

<blockquote>
  <p>Support Window Interfaces</p>
</blockquote>

<ul>
  <li>Provides a simple window API for OpenGL</li>
  <li>Old and limited</li>
</ul>

<h3 id="freeglut">FreeGLUT</h3>

<blockquote>
  <p>Support Window Interfaces</p>
</blockquote>

<ul>
  <li>X-Consortiumì—ì„œ ë§Œë“¬</li>
</ul>

<h3 id="glewopengl-extension-wrangler">GLEW(OpenGL Extension Wrangler)</h3>

<blockquote>
  <p>To Load OpenGL Extension</p>
</blockquote>

<ul>
  <li>Cross Platform OpenSource OpenGL Extension Loading Library</li>
  <li>Provides efficient run-time mechanisms for determining which OpenGL extensions are supported on the target platform.</li>
</ul>

<h2 id="first-opengl-program">First OpenGL Program</h2>

<blockquote>
  <font color="black">**Assignment_1_Review**ë¥¼ ë³´ëŠ” ê²ƒì´ ì–´ì©Œë©´ ë” ì´í•´ê°€ ì˜ ê°ˆ ê²ƒì´ë‹¤.</font>
</blockquote>

<h3 id="sending-vertex-data-to-opengl">Sending Vertex Data to OpenGL</h3>

<ul>
  <li>Buffer allocation &amp; Initialization
    <ul>
      <li>ëª¨ë“  data <strong>buffer object</strong>ì— ì €ì¥ëœë‹¤.</li>
      <li><strong>buffer object</strong>ëŠ” OpenGLì—ì„œ ê´€ë¦¬ê°€ ëœë‹¤.</li>
      <li><strong>getBufferData()</strong>ë¥¼ í†µí•´ì„œ <strong>buffer object</strong>ì˜ ë©”ëª¨ë¦¬ ê³µê°„ì„ í™•ë³´í•œë‹¤.</li>
    </ul>
  </li>
  <li>
    <p>ì˜ˆì‹œ</p>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GLunit</span> <span class="n">Bufers</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Buffers</span><span class="p">);</span>	<span class="c1">//buffer object ìƒì„±</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="n">BUFFERS</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>	<span class="c1">//openGLì—ì„œ Binding Target 0ë²ˆì§¸ GL_ARRAY_BUFFERì™€ ì—°ê²°</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span><span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span> <span class="c1">//vetice dataë¥¼ GL_ARRAY_BUFFERë¥¼ í†µí•´ì„œ í• ë‹¹ëœ Buffer Objectì— ì¶”ê°€í•œë‹¤.</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <font color="red">GL_ARRAY_BUFFERë¥¼ ë”°ë¡œ ê´€ë¦¬í•˜ëŠ” ì´ìœ ? ì™œ ì§ì ‘ Buffer Object Listì— ì¶”ê°€í•˜ì§€ ì•ŠëŠ”ê°€?</font>
      </li>
    </ul>
  </li>
  <li>
    <p>Request for Rendering</p>
  </li>
  <li>vertice dataê°€ bufferì— ì˜®ê²¨ì§„ ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.</li>
  <li>ê·¸ë ‡ë‹¤ë©´ ì´ì œ, OpenGLì—ì„œ ê·¸ë¦¬ëŠ” ëª…ë ¹ì–´ë¥¼ í†µí•´ì„œ ê·¸ë ¤ë³´ì.
    <ul>
      <li>glDrawArray(); accessing buffer elemnents in a <strong>sequencial</strong></li>
      <li>glDrawElements();  accessing buffer elemnents in an <strong>indexed order</strong></li>
    </ul>
  </li>
</ul>

<h3 id="pass-through-vertex-shader">Pass-through Vertex Shader</h3>

<ul>
  <li>Vertex Shader
    <ul>
      <li>Drawing Commandê°€ í˜¸ì¶œë˜ì—ˆì„ ë•Œ, ì‹¤í–‰ë˜ëŠ” ë‹¨ê³„</li>
      <li><strong>Pass-through Vertex Shader</strong>ëŠ” Vertex Dataë¥¼ <strong>ë³µì‚¬</strong>í•˜ì—¬ ë³´ë‚´ëŠ” ì‘ì—… ì¤‘ ê°„ë‹¨í•œ ì‘ì—…ì´ë‹¤.</li>
    </ul>
  </li>
</ul>

<h3 id="fragment-shader-for-coloring">Fragment Shader for coloring</h3>

<ul>
  <li>Rasterizationì—ì„œ ë§Œë“¤ì–´ì§„ frameì— ëŒ€í•˜ì—¬ ìƒ‰ì„ ë¶€ì—¬í•˜ëŠ” ë‹¨ê³„
    <ul>
      <li>Rasterization: Projection Planeì— ê·¸ë ¤ì§„ ì‚¬ë¬¼ì„ pixel gridë¡œ ê°€ê³µí•˜ëŠ” ë‹¨ê³„ì´ë‹¤.</li>
    </ul>
  </li>
</ul>

<h2 id="ì˜ˆì‹œ">ì˜ˆì‹œ</h2>

<ul>
  <li>./triangle.cpp</li>
</ul>

<h3 id="í™˜ê²½-êµ¬ì¶•">í™˜ê²½ êµ¬ì¶•</h3>

<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#glut ì„¤ì¹˜</span>
brew <span class="nb">install </span>glut
<span class="c"># ë§Œì•½ xquarz ê´€ë ¨ error ê°€ ëœ¨ë©´ ì•„ë˜ cmd ì‹¤í–‰</span>
brew cask <span class="nb">install </span>xquartz

<span class="c">#glew ì„¤ì¹˜</span>
brew <span class="nb">install </span>glew

</code></pre></div></div>

:ET